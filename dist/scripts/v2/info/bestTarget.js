import { FilePaths } from 'data/FilePaths';
import { FileSystem } from 'scripts/utils/fsUtils';
/**
 * Evaluates a list of hackable servers and identifies the most profitable target
 * for hacking activities, based on a scoring system. The script reads a list of previously identified
 * hackable servers, assesses each based on its profitability and security level, and records
 * the best target into a file. The decision is based on the ratio of potential money gains to the
 * minimum security level of each server, while excluding servers that take too long to weaken.
 * This script uses a custom `FileSystem` class to facilitate file operations.
 */
export async function main(ns) {
    // Instantiate FileSystem classes for file operations, targeting specific files for hackable targets and the best target.
    const hackableTargetsFile = new FileSystem(ns, FilePaths.HACKABLE_TARGETS);
    const bestTargetFile = new FileSystem(ns, FilePaths.BEST_TARGET);
    const currentBest = await bestTargetFile.read();
    const MAX_MINUTES = 30;
    // Read the list of hackable targets from the file.
    const TARGETS = (await hackableTargetsFile.read())?.filter(({ name }) => !hasLongWeakenTime(ns, name, 1000 * 60 * MAX_MINUTES));
    if (!TARGETS) {
        ns.tprint('ERROR: Failed to read hackable targets from the file.');
        return;
    }
    // Define the maximum allowed time for weakening a server in minutes.
    let score = 0;
    let result = currentBest ?? TARGETS[0];
    // Evaluate each target based on its weaken time and profitability-security ratio.
    for (const target of TARGETS) {
        const { moneyMax, minDifficulty } = target.info;
        assert(moneyMax !== undefined && moneyMax > 0 && minDifficulty !== undefined, 'Invalid target info');
        // Calculate the score as the ratio of maximum potential money to minimum security level.
        const newScore = moneyMax / minDifficulty;
        if (newScore > score) {
            score = newScore; // Update the best score found.
            result = target; // Update the best target found.
        }
    }
    if (currentBest?.name !== result.name) {
        ns.print(`INFO bestServer: ${result.name}`);
        // Write the name of the best target server to the file.
        await bestTargetFile.write(result, 'w');
    }
}
const hasLongWeakenTime = (ns, target, ms) => {
    return ns.getWeakenTime(target) > ms;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVzdFRhcmdldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zY3JpcHRzL3YyL2luZm8vYmVzdFRhcmdldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ25EOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLElBQUksQ0FBQyxFQUFNO0lBQy9CLHlIQUF5SDtJQUN6SCxNQUFNLG1CQUFtQixHQUFHLElBQUksVUFBVSxDQUN4QyxFQUFFLEVBQ0YsU0FBUyxDQUFDLGdCQUFnQixDQUMzQixDQUFDO0lBQ0YsTUFBTSxjQUFjLEdBQUcsSUFBSSxVQUFVLENBQ25DLEVBQUUsRUFDRixTQUFTLENBQUMsV0FBVyxDQUN0QixDQUFDO0lBQ0YsTUFBTSxXQUFXLEdBQUcsTUFBTSxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7SUFFaEQsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDO0lBQ3ZCLG1EQUFtRDtJQUNuRCxNQUFNLE9BQU8sR0FBRyxDQUFDLE1BQU0sbUJBQW1CLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQ3hELENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQ3BFLENBQUM7SUFFRixJQUFJLENBQUMsT0FBTyxFQUFFO1FBQ1osRUFBRSxDQUFDLE1BQU0sQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1FBQ25FLE9BQU87S0FDUjtJQUVELHFFQUFxRTtJQUVyRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxJQUFJLE1BQU0sR0FBRyxXQUFXLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXZDLGtGQUFrRjtJQUNsRixLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sRUFBRTtRQUM1QixNQUFNLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFFaEQsTUFBTSxDQUNKLFFBQVEsS0FBSyxTQUFTLElBQUksUUFBUSxHQUFHLENBQUMsSUFBSSxhQUFhLEtBQUssU0FBUyxFQUNyRSxxQkFBcUIsQ0FDdEIsQ0FBQztRQUVGLHlGQUF5RjtRQUN6RixNQUFNLFFBQVEsR0FBRyxRQUFTLEdBQUcsYUFBYyxDQUFDO1FBQzVDLElBQUksUUFBUSxHQUFHLEtBQUssRUFBRTtZQUNwQixLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsK0JBQStCO1lBQ2pELE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxnQ0FBZ0M7U0FDbEQ7S0FDRjtJQUVELElBQUksV0FBVyxFQUFFLElBQUksS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFO1FBQ3JDLEVBQUUsQ0FBQyxLQUFLLENBQUMsb0JBQW9CLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQzVDLHdEQUF3RDtRQUN4RCxNQUFNLGNBQWMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQ3pDO0FBQ0gsQ0FBQztBQUVELE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxFQUFNLEVBQUUsTUFBYyxFQUFFLEVBQVUsRUFBVyxFQUFFO0lBQ3hFLE9BQU8sRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDdkMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTlMgfSBmcm9tICdAbnMnO1xuaW1wb3J0IHsgRmlsZVBhdGhzIH0gZnJvbSAnZGF0YS9GaWxlUGF0aHMnO1xuaW1wb3J0IHsgU2VydmVyTm9kZUR0byB9IGZyb20gJ2RhdGEvU2VydmVyTm9kZSc7XG5pbXBvcnQgeyBGaWxlU3lzdGVtIH0gZnJvbSAnc2NyaXB0cy91dGlscy9mc1V0aWxzJztcbi8qKlxuICogRXZhbHVhdGVzIGEgbGlzdCBvZiBoYWNrYWJsZSBzZXJ2ZXJzIGFuZCBpZGVudGlmaWVzIHRoZSBtb3N0IHByb2ZpdGFibGUgdGFyZ2V0XG4gKiBmb3IgaGFja2luZyBhY3Rpdml0aWVzLCBiYXNlZCBvbiBhIHNjb3Jpbmcgc3lzdGVtLiBUaGUgc2NyaXB0IHJlYWRzIGEgbGlzdCBvZiBwcmV2aW91c2x5IGlkZW50aWZpZWRcbiAqIGhhY2thYmxlIHNlcnZlcnMsIGFzc2Vzc2VzIGVhY2ggYmFzZWQgb24gaXRzIHByb2ZpdGFiaWxpdHkgYW5kIHNlY3VyaXR5IGxldmVsLCBhbmQgcmVjb3Jkc1xuICogdGhlIGJlc3QgdGFyZ2V0IGludG8gYSBmaWxlLiBUaGUgZGVjaXNpb24gaXMgYmFzZWQgb24gdGhlIHJhdGlvIG9mIHBvdGVudGlhbCBtb25leSBnYWlucyB0byB0aGVcbiAqIG1pbmltdW0gc2VjdXJpdHkgbGV2ZWwgb2YgZWFjaCBzZXJ2ZXIsIHdoaWxlIGV4Y2x1ZGluZyBzZXJ2ZXJzIHRoYXQgdGFrZSB0b28gbG9uZyB0byB3ZWFrZW4uXG4gKiBUaGlzIHNjcmlwdCB1c2VzIGEgY3VzdG9tIGBGaWxlU3lzdGVtYCBjbGFzcyB0byBmYWNpbGl0YXRlIGZpbGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1haW4obnM6IE5TKSB7XG4gIC8vIEluc3RhbnRpYXRlIEZpbGVTeXN0ZW0gY2xhc3NlcyBmb3IgZmlsZSBvcGVyYXRpb25zLCB0YXJnZXRpbmcgc3BlY2lmaWMgZmlsZXMgZm9yIGhhY2thYmxlIHRhcmdldHMgYW5kIHRoZSBiZXN0IHRhcmdldC5cbiAgY29uc3QgaGFja2FibGVUYXJnZXRzRmlsZSA9IG5ldyBGaWxlU3lzdGVtPFNlcnZlck5vZGVEdG9bXT4oXG4gICAgbnMsXG4gICAgRmlsZVBhdGhzLkhBQ0tBQkxFX1RBUkdFVFNcbiAgKTtcbiAgY29uc3QgYmVzdFRhcmdldEZpbGUgPSBuZXcgRmlsZVN5c3RlbTxTZXJ2ZXJOb2RlRHRvPihcbiAgICBucyxcbiAgICBGaWxlUGF0aHMuQkVTVF9UQVJHRVRcbiAgKTtcbiAgY29uc3QgY3VycmVudEJlc3QgPSBhd2FpdCBiZXN0VGFyZ2V0RmlsZS5yZWFkKCk7XG5cbiAgY29uc3QgTUFYX01JTlVURVMgPSAzMDtcbiAgLy8gUmVhZCB0aGUgbGlzdCBvZiBoYWNrYWJsZSB0YXJnZXRzIGZyb20gdGhlIGZpbGUuXG4gIGNvbnN0IFRBUkdFVFMgPSAoYXdhaXQgaGFja2FibGVUYXJnZXRzRmlsZS5yZWFkKCkpPy5maWx0ZXIoXG4gICAgKHsgbmFtZSB9KSA9PiAhaGFzTG9uZ1dlYWtlblRpbWUobnMsIG5hbWUsIDEwMDAgKiA2MCAqIE1BWF9NSU5VVEVTKVxuICApO1xuXG4gIGlmICghVEFSR0VUUykge1xuICAgIG5zLnRwcmludCgnRVJST1I6IEZhaWxlZCB0byByZWFkIGhhY2thYmxlIHRhcmdldHMgZnJvbSB0aGUgZmlsZS4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIG1heGltdW0gYWxsb3dlZCB0aW1lIGZvciB3ZWFrZW5pbmcgYSBzZXJ2ZXIgaW4gbWludXRlcy5cblxuICBsZXQgc2NvcmUgPSAwO1xuICBsZXQgcmVzdWx0ID0gY3VycmVudEJlc3QgPz8gVEFSR0VUU1swXTtcblxuICAvLyBFdmFsdWF0ZSBlYWNoIHRhcmdldCBiYXNlZCBvbiBpdHMgd2Vha2VuIHRpbWUgYW5kIHByb2ZpdGFiaWxpdHktc2VjdXJpdHkgcmF0aW8uXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIFRBUkdFVFMpIHtcbiAgICBjb25zdCB7IG1vbmV5TWF4LCBtaW5EaWZmaWN1bHR5IH0gPSB0YXJnZXQuaW5mbztcblxuICAgIGFzc2VydChcbiAgICAgIG1vbmV5TWF4ICE9PSB1bmRlZmluZWQgJiYgbW9uZXlNYXggPiAwICYmIG1pbkRpZmZpY3VsdHkgIT09IHVuZGVmaW5lZCxcbiAgICAgICdJbnZhbGlkIHRhcmdldCBpbmZvJ1xuICAgICk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNjb3JlIGFzIHRoZSByYXRpbyBvZiBtYXhpbXVtIHBvdGVudGlhbCBtb25leSB0byBtaW5pbXVtIHNlY3VyaXR5IGxldmVsLlxuICAgIGNvbnN0IG5ld1Njb3JlID0gbW9uZXlNYXghIC8gbWluRGlmZmljdWx0eSE7XG4gICAgaWYgKG5ld1Njb3JlID4gc2NvcmUpIHtcbiAgICAgIHNjb3JlID0gbmV3U2NvcmU7IC8vIFVwZGF0ZSB0aGUgYmVzdCBzY29yZSBmb3VuZC5cbiAgICAgIHJlc3VsdCA9IHRhcmdldDsgLy8gVXBkYXRlIHRoZSBiZXN0IHRhcmdldCBmb3VuZC5cbiAgICB9XG4gIH1cblxuICBpZiAoY3VycmVudEJlc3Q/Lm5hbWUgIT09IHJlc3VsdC5uYW1lKSB7XG4gICAgbnMucHJpbnQoYElORk8gYmVzdFNlcnZlcjogJHtyZXN1bHQubmFtZX1gKTtcbiAgICAvLyBXcml0ZSB0aGUgbmFtZSBvZiB0aGUgYmVzdCB0YXJnZXQgc2VydmVyIHRvIHRoZSBmaWxlLlxuICAgIGF3YWl0IGJlc3RUYXJnZXRGaWxlLndyaXRlKHJlc3VsdCwgJ3cnKTtcbiAgfVxufVxuXG5jb25zdCBoYXNMb25nV2Vha2VuVGltZSA9IChuczogTlMsIHRhcmdldDogc3RyaW5nLCBtczogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiBucy5nZXRXZWFrZW5UaW1lKHRhcmdldCkgPiBtcztcbn07XG4iXX0=